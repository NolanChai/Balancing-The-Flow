sx, sy, sz, dx, dy, dz, w, h, l) {
	let m = Math.floor((h - 1) / 2);
	let n = Math.floor((l - 1) / 2);

	// mirroring on the x axis:
	for (let y = 0; y < w; ++y) {
		duplicateBlock(sx + 2 * m, sy + m, sz + n, dx, dy, dz, w, h - 1, l);
	}

	// mirroring on the y axis:
	for (let x = 0; x < w / 2; ++x) {
		duplicateBlock(sx, sy + 2 * m, sz + n, dx, dy, dz, w - 1, h - 1, l);
	}

	// mirroring on the z axis:
	for (let y = 0; y < w / 2; ++y) {
		duplicateBlock(sx + m, sy, sz + 2 * n, dx, dy, dz, w - 1, h, l);
	}
}

function rotateFacing(sx, sy, sz, dx, dy, dz, w, h, l, rotation) {
	let rot = rotation / 45;
	let rad = (rot * Math.PI / 180).toFixed(2);

	if (!world.isRemote && !rotateBlock) {
		console.log(`World is not running as a server, rotation not supported.`);
	} else if ((sx + dx < sx || sx + dx >= world.getMaximumDimensionX()) || (sy + dy < sy || sy + dy >= world.getMaximumDimensionY()) || (sz + dz < sz || sz + dz >= world.getMaximumDimensionZ())) {
		console.log(`World is not running as a server, block is outside bounds.`);
	} else if (rot > 80 || rot <= -80) {
		console.log(`World is not running as a server, rotation out of range`);
	} else {
		// rotate x and z blocks
		for (let i = 1; i < 6; i++) {
			rotateBlock(sx + dx - dx * Math.sin(rad), sy + dy + dy * Math.cos(rad), sz + dz, dx + dx * Math.cos(rad) - dz * Math.sin(rad), sy + dy - dy * Math.cos(rad), dz + dz * Math.sin(rad) + dx * Math.sin(rad), w, h, l);
		}

		// rotate y blocks
		for (let i = 1; i < 6; i++) {
			rotateBlock(sx + dx - dz * Math.cos(rad) + dx * Math.sin(rad), sy + dy, sz + dz + dz * Math.sin(rad) + dz * Math.sin(rad), dx + dx * Math.cos(rad) - dz * Math.sin(rad), sy + dy - dy * Math.cos(rad), dz + dy * Math.sin(rad) + dz * Math.cos(rad), w, h / 2, l);
		}

		// rotate x and y blocks
		for (let i = 1; i < 6; i++) {
			rotateBlock(sx - dx * Math.sin(rad) + dx - dz * Math.cos(rad), sy, sz + dz + dz * Math.sin(rad) + dz * Math.sin(rad), dx + dx * Math.cos(rad) - dz * Math.sin(rad), sy + dy - dy * Math.cos(rad), dz + dz * Math.sin(rad) + dy * Math.sin(rad), w, h / 2, l);
		}
	}
}