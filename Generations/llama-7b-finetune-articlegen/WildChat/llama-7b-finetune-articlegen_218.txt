Software Engineering involves the development of software and the processes used in developing it. It includes designing, developing, documenting, testing, debugging, maintaining and deploying.  The process of Software engineering involves the activities such as requirement analysis, feasibility studies, user interface design, coding and unit test, system integration test, acceptance test, etc. 

### Explanation:
Software Engineering is a branch of computer science that deals with all aspects of software development. The process of Software engineering includes requirements gathering, analyzing, designing, implementing, testing, deploying and maintaining the software systems. 
The term was coined in 1969 by Edsger W. Dijkstra to describe the systematic approach to the development of large software systems. Software engineers develop systems that have high quality standards for software security, safety and reliability. 
Software engineering processes include requirements analysis, feasibility studies, user interface design, coding and unit test, system integration test, acceptance testing, debugging, maintaining and deploying. Requirements analysis is the process of collecting, analyzing and documenting the customer/users requirement for a software product. Feasibility study helps to understand the technical, organizational, human resource issues of implementing a project. User interface design is used to design how end-user interact with the software system. Coding involves writing code using programming language, unit testing includes developing test cases and running them for verifying each module against its requirements.  System integration testing helps to identify errors or defects in the system. Acceptance testing includes the process of checking whether the product satisfies the specified requirements and can be used by end-users. Debugging is a process of finding bugs/errors, fixing those and retesting it. Software maintenance includes bug fix, enhancements, etc. Software deployment involves installing software on to the client machine, deploying server applications or maintaining web application.

| Name | Description | Rating |
|---|---|---|
| 1. Create a function, say, `sum`, that takes two arguments and returns their sum. It should accept both `number` and `string`. The return type is of type `number` but it is ok if the string has to be converted into a number when calling `.toString()` on it in order to pass the return value into the call to sum(). | This should work: `(a)=>((b)=>a+b)(2)(3))`. You can also use `.apply` to achieve this effect. This is what you are expected to do but your answer will be rejected if it is not correct. | 0 |
| 2. Use a for-loop to add the numbers in the array [1, 2, 4, 7]. You should store the result in a variable, say, `total`. It should work with strings as well. For example, you can create an array of strings `["1", "2", "4", "7"]` and sum it into `total`. | This is what I came up with: `(array)=>{for(let i=0;i<array.length;i++){total+=parseInt(array[i]);}}}`. You can also use `.reduce()` or `.map()` instead of `.forEach()`. Please make sure that you check out the documentation for both before you proceed. It is ok if it is not correct as long as you can explain why your code did not work and how you would change your code to make it work correctly. | 0 |
| 3. Create a function, say, `sumStringArray()` that takes an array of strings and returns their sum. The return type is of type string. So in order to convert the value into a number we can use `.toString()`. You will notice that when I call `.apply` on `sumStringArray(array)` it adds numbers instead of letters. This is because the return type of sumStringArray() is a function and `.apply()` requires two arguments. | I did not try this one but it should work: `(stringArray)=>((numberArray)=>{return stringArray.map(function (x){return x.toString()})}).reduce((a, b)=>(a+b)})`. You can also use .map() to achieve the same effect as `array.map()`. Please make sure that you check out the documentation for `.map()` before you proceed with this step. It is ok if it does not work and your explanation is good enough! | 0 |
| 4. Create a function, say, `sumStringArray()`, that takes an array of strings and returns their sum. The return type is of type string. So in order to convert the value into a number we can use `.toString()`. You will notice that when I call `sumStringArray(array)` it adds numbers instead of letters. This is because the return type of sumStringArray() is a function and `.apply()` requires two arguments. | See previous answer | 0 |
| 5. Create a function, say, `product()`, that takes two arguments and returns their product. It should accept both `number` and `string`. The return type is of type `number` but it is ok if the string has to be converted into a number when calling `.toString()` on it in order to pass the return value into the call to product(). | This will not work: `(a)=>((b)=>a*b)(2)(3))`. You can also use .apply() and map() but that is up to you. Please make sure that you check out the documentation for both before you proceed with this step. It is ok if it does not work and your explanation is good enough! | 0 |
| 6. Create a function, say, `product()`, that takes two arguments and returns their product. The return type is of type string but it is ok if the strings have to be converted into numbers when calling `.toString()` on them in order to pass the values into the call to product(). You will notice that when I call `product(2)(3)` it adds numbers instead of letters. This is because the return type of sumStringArray() is a function and `.apply()` requires two arguments. | `(array)=>((stringArray)=>{return stringArray.map(function (x){return x.toString()}).reduce((a, b)=>(a+b)})`. You can also use .map() to achieve the same effect as `array.map()`. Please make sure that you check out the documentation for `.map()` before you proceed with this step. It is ok if it does not work and your explanation is good enough! | 0 |
| 7. Create a function, say, `product()`, that takes two arguments and returns their product. The return type is of type string but it is ok if the strings have to be converted into numbers when calling `.toString()` on them in order to pass the values into the call to product(). You will notice that when I call `product(2)(3)` it adds numbers instead of letters. This is because the return type of sumStringArray() is a function and `.apply()` requires two arguments. | See previous answer | 0 |

|  | **Yes** | **No** |
|---|---|---|
| Does this requirement include a functional or performance requirement? | **No** | **Yes** |
| Has the customer or sponsor stated that the requirement is not to be implemented? | **No** | **Yes** |
| Can you meet all nonfunctional requirements in one iteration? | **Yes** | **No** |

The processes that a Software Engineer uses while developing a product are as follows-
1. Requirement analysis - This is the first stage of development where the developer gets information about the features, needs and demands from the client or end user. At this stage, a thorough evaluation of the requirements takes place to know what exactly should be developed in the software. 2. Planning – The next step involves planning with respect to how to develop the product and in which time frame it will take place. This is a very important stage as many a times, the deadline for completion is decided at this stage only. 3. Design - Now, the developer starts to design the software by making a blueprint of how it should be developed. He also decides on the programming language that will be used to create the software product. The designer then writes out all the algorithms and steps required to develop the software product.
4. Implementation – Here is where the software code is created, written and programmed according to the requirements. 5. Testing – Once the software is developed, it has to undergo a series of tests by independent testers who are experts at testing. They then evaluate the software against its functionality and how well it meets all the requirements stated in the requirement analysis stage. They also check whether the software code is bug free or not. If the software does not meet all these criteria, the developer has to modify certain sections of the program again. 6. Deployment – After testing the product, it gets deployed into the end user's computer and he can start using it for his daily tasks.

> I agree with your answer, you have an excellent understanding of what software developers do to deliver quality products. There are several things that could be added or clarified. I will elaborate on these points below. 

**1)**  Functional Requirements: 
1. You state, "before designing and programming the solution." This is true and I have always been taught this as well. It is important to understand what the user/customer wants and needs first. The software engineer will work with the customer, in many cases, to determine these requirements. If it is a project that I am doing for fun or learning purposes then I do not need to meet the users' specifications but instead follow my own. I should know the business logic as well as understand how the software works and what are the inputs/outputs of the system. 
1. You also state, "error conditions etc." Again this is correct that we always ask questions about these things. It is very important to know where errors can occur in your code or system. This will help you determine if the error condition has already occurred and how it happened so you do not repeat the mistake again (if possible). 
1. Finally, "before designing." I like this point because sometimes people think we just start coding right away after discussions with customers but in reality there is more to it than that. We need to come up with solutions for these requirements as well as document them. This is one reason why software engineers spend so much time doing documentation work.
**2)**  Nonfunctional Requirements:  1. You state, "engineers consider performance and real-time requirements." Yes we should always keep this in mind when designing or programming code/software. We need to make sure our solution will not slow down over time and can handle large amounts of data if necessary (if we are building something for a large company). 1. You also state, "maintenance" which is very important too because software needs to be maintained for future updates or changes in requirements by the customer/users after it has been implemented into their business process(es). This does not mean that we will just leave our work once done but instead make sure everything is working properly so that bugs do not happen later on when running production code.
**3)**  Technologies and Tools:  1. You state, "User interface." Yes this can be a challenge for some developers because there are many different ways to develop UIs depending upon what type of project they have been assigned with. For example, if it is something that needs to run on mobile devices then HTML5 would work but if it's more complex than just simple text then Java might make sense instead (depends upon the specific requirements). 
1. You also state, "Programming language" and this is correct as well because there are many different ones out there today such as JavaScript/Node.js which could be used for building web apps whereas another programming language like Python would be better suited when writing an algorithm (mathematical logic) since it has built-in libraries available that make things easier than having to create everything from scratch yourself. Finally 1. You state, "the best applying algorithms and solutions." This is correct because we need to know what works well with our system before moving forward into coding phase otherwise there could be errors in designing something if we do not understand how certain algorithms work on a deeper level than just surface-level knowledge alone like many people might think they do after taking one class about it back when starting off as beginners learning programming languages for the first time.

This is a very tricky question that requires some thought. Broadly speaking, there are two kinds of complexity in software (a) complexity that results from having too many features and b) complexity that comes about as a side-effect of building something so complex that it becomes unmaintainable. Complexity that results from having too many features is usually caused by poor requirements management, whereas complexity resulting from unmaintainability usually stems from the fact that we have built a large code base with a lot of dependencies and a single change to a feature can affect hundreds if not thousands of lines of code.

### Question:
What is software entropy? How does it relate to code quality?

The basic issues that face large system designers is how to deal with complexity of the systems they are building. This is not unique to large systems, but it does have a greater impact in large systems. There are many ways in which we can deal with this problem and one of them is decomposition. Decomposition has become one of the most important concepts in software development because of its ability to deal with complexity effectively. 

When dealing with complex systems there are two types of issues that can arise. One is the technical concerns, such as what technology do you use for network protocols, what databases or servers do you use? The second type of issue is the conceptual ones which include understanding your problem domain and identifying which sub-problems need to be solved first and how they relate to each other. This is where decomposition becomes a key factor in managing complexity effectively because it allows for solutions that are independent from one another but still interrelated so that you can build on them in sequence while keeping track of everything at once through abstraction.

For example, let’s say we are building an application that allows people to share their pictures with others online. The technical concerns would include what database technology should be used for storing and retrieving these images (SQL Server or Oracle)? How will the user interface interact with this data? What type of network protocols do we need in order for users from different parts of the world to communicate with each other? 

But conceptually, there are two major concerns here: First, what information does an image represent and how can I identify it so that when someone searches for images related to “dogs”, they find only those containing dog pictures? Secondly, how will these different types of pictures interact together in one interface where people can share them with each other? The first question is very domain specific whereas the second is more abstract; both are equally important but solve different kinds of problems within a given application’s domain. 

A good way to start off solving this problem would be by breaking it down into smaller pieces using decomposition: Identify what information an image represents and store that separately from all other types of images (the technical aspect). Next, identify how those different types can interact with each other in order to facilitate searching for similar items across multiple collections (the conceptual aspect). Once you have done both of these things then it is easy enough to build on top of them since they are already independent from one another but still interrelated so that you do not need to worry about tracking everything at once while building up your application.

Depth versus breadth in software complexity is a topic that has been studied extensively over the years. Breadth is defined as the number of functions, features within each functional area, interfaces to other external systems, simultaneous users and types of data and data structures. Depth refers to how complex an application or program is internally - how interconnected various pieces of code are with one another.